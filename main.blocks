<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="(owZl9aNcfXJ/]OjjV~`" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="p*Y9%$O#soL4{2RABQKE" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace robotAtom {" line1="    const PCA9685_ADDRESS = 0x40;" line2="    const MODE1 = 0x00;" line3="    const PRESCALE = 0xFE;" line4="    const LED0_ON_L = 0x06;" line5="" line6="    export enum Servos {" line7="        S1 = 0x01," line8="        S2 = 0x02," line9="        S3 = 0x03," line10="        S4 = 0x04," line11="        S5 = 0x05," line12="        S6 = 0x06," line13="        S7 = 0x07," line14="        S8 = 0x08" line15="    }" line16="" line17="    export enum Motors {" line18="        M1A = 0x1," line19="        M1B = 0x2," line20="        M2A = 0x3," line21="        M2B = 0x4" line22="    }" line23="" line24="    let initialized = false;" line25="" line26="    function i2cwrite(addr: number, reg: number, value: number) {" line27="&#9;&#9;let buf = pins.createBuffer(2);" line28="&#9;&#9;buf[0] = reg;" line29="&#9;&#9;buf[1] = value;" line30="&#9;&#9;pins.i2cWriteBuffer(addr, buf);" line31="&#9;}" line32="" line33="&#9;function i2ccmd(addr: number, value: number) {" line34="&#9;&#9;let buf2 = pins.createBuffer(1);" line35="&#9;&#9;buf2[0] = value;" line36="&#9;&#9;pins.i2cWriteBuffer(addr, buf2);" line37="&#9;}" line38="" line39="&#9;function i2cread(addr: number, reg: number) {" line40="&#9;&#9;pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);" line41="&#9;&#9;let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);" line42="&#9;&#9;return val;" line43="&#9;}" line44="" line45="&#9;function initPCA9685(): void {" line46="&#9;&#9;i2cwrite(PCA9685_ADDRESS, MODE1, 0x00);" line47="&#9;&#9;setFreq(50);" line48="&#9;&#9;for (let idx = 0; idx &lt; 16; idx++) {" line49="&#9;&#9;&#9;setPwm(idx, 0, 0);" line50="&#9;&#9;}" line51="&#9;&#9;initialized = true;" line52="&#9;}" line53="" line54="    function setFreq(freq: number): void {" line55="&#9;&#9;let prescaleval = 25000000;" line56="&#9;&#9;prescaleval /= 4096;" line57="&#9;&#9;prescaleval /= freq;" line58="&#9;&#9;prescaleval -= 1;" line59="&#9;&#9;let prescale = prescaleval;" line60="&#9;&#9;let oldmode = i2cread(PCA9685_ADDRESS, MODE1);" line61="&#9;&#9;let newmode = (oldmode &amp; 0x7F) | 0x10;" line62="&#9;&#9;i2cwrite(PCA9685_ADDRESS, MODE1, newmode);" line63="&#9;&#9;i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale);" line64="&#9;&#9;i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);" line65="&#9;&#9;control.waitMicros(5000);" line66="&#9;&#9;i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);" line67="&#9;}" line68="" line69="    function setPwm(channel: number, on: number, off: number): void {" line70="&#9;&#9;if (channel &lt; 0 || channel &gt; 15) return;" line71="&#9;&#9;let buf3 = pins.createBuffer(5);" line72="&#9;&#9;buf3[0] = LED0_ON_L + 4 * channel;" line73="&#9;&#9;buf3[1] = on &amp; 0xff;" line74="&#9;&#9;buf3[2] = (on &gt;&gt; 8) &amp; 0xff;" line75="&#9;&#9;buf3[3] = off &amp; 0xff;" line76="&#9;&#9;buf3[4] = (off &gt;&gt; 8) &amp; 0xff;" line77="&#9;&#9;pins.i2cWriteBuffer(PCA9685_ADDRESS, buf3);" line78="&#9;}" line79="" line80="    // motors function" line81="    function stopMotor(index: number) {" line82="&#9;&#9;setPwm((index - 1) * 2, 0, 0);" line83="&#9;&#9;setPwm((index - 1) * 2 + 1, 0, 0);" line84="&#9;}" line85="" line86="    //% blockId=robotAtom_motor_run block=&quot;Motor|%index|speed %speed&quot;" line87="&#9;//% weight=85" line88="&#9;//% speed.min=-255 speed.max=255" line89="&#9;//% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line90="&#9;export function MotorRun(index: Motors, speed: number): void {" line91="&#9;&#9;if (!initialized) {" line92="&#9;&#9;&#9;initPCA9685()" line93="&#9;&#9;}" line94="&#9;&#9;speed = speed * 16; // map 255 to 4096" line95="&#9;&#9;if (speed &gt;= 4096) {" line96="&#9;&#9;&#9;speed = 4095" line97="&#9;&#9;}" line98="&#9;&#9;if (speed &lt;= -4096) {" line99="&#9;&#9;&#9;speed = -4095" line100="&#9;&#9;}" line101="&#9;&#9;if (index &gt; 4 || index &lt;= 0)" line102="&#9;&#9;&#9;return" line103="&#9;&#9;let pp = (index - 1) * 2" line104="&#9;&#9;let pn = (index - 1) * 2 + 1" line105="&#9;&#9;if (speed &gt;= 0) {" line106="&#9;&#9;&#9;setPwm(pp, 0, speed)" line107="&#9;&#9;&#9;setPwm(pn, 0, 0)" line108="&#9;&#9;} else {" line109="&#9;&#9;&#9;setPwm(pp, 0, 0)" line110="&#9;&#9;&#9;setPwm(pn, 0, -speed)" line111="&#9;&#9;}" line112="&#9;}" line113="" line114="" line115="    //% blockId=robotAtom_stop block=&quot;Motor Stop|%index|&quot;" line116="&#9;//% weight=80" line117="&#9;export function MotorStop(index: Motors): void {" line118="&#9;&#9;MotorRun(index, 0);" line119="&#9;}" line120="" line121="    //% blockId=robotAtom_stop_all block=&quot;Motor Stop All&quot;" line122="&#9;//% weight=79" line123="&#9;//% blockGap=50" line124="&#9;export function MotorStopAll(): void {" line125="&#9;&#9;if (!initialized) {" line126="&#9;&#9;&#9;initPCA9685()" line127="&#9;&#9;}" line128="&#9;&#9;for (let idx2 = 1; idx2 &lt;= 4; idx2++) {" line129="&#9;&#9;&#9;stopMotor(idx2);" line130="&#9;&#9;}" line131="&#9;}" line132="" line133="    /**" line134="&#9; * Execute two motors at the same time" line135="&#9; * @param motor1 First Motor; eg: M1A, M1B" line136="&#9; * @param speed1 [-255-255] speed of motor; eg: 150, -150" line137="&#9; * @param motor2 Second Motor; eg: M2A, M2B" line138="&#9; * @param speed2 [-255-255] speed of motor; eg: 150, -150" line139="&#9;*/" line140="&#9;//% blockId=robotAtom_motor_dual block=&quot;Motor|%motor1|speed %speed1|%motor2|speed %speed2&quot;" line141="&#9;//% weight=84" line142="&#9;//% speed1.min=-255 speed1.max=255" line143="&#9;//% speed2.min=-255 speed2.max=255" line144="&#9;//% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line145="&#9;export function MotorRunDual(motor1: Motors, speed1: number, motor2: Motors, speed2: number): void {" line146="&#9;&#9;MotorRun(motor1, speed1);" line147="&#9;&#9;MotorRun(motor2, speed2);" line148="&#9;}" line149="" line150="" line151="    /**" line152="     * Servo Execute" line153="     * @param index Servo Channel; eg: S1" line154="     * @param degree [0-180] degree of servo; eg: 0, 90, 180" line155="    */" line156="    //% blockId=robotAtom_servo block=&quot;Servo|%index|degree %degree&quot;" line157="    //% weight=100" line158="    //% degree.min=0 degree.max=180" line159="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line160="    export function Servo(index: Servos, degree: number): void {" line161="        if (!initialized) {" line162="            initPCA9685()" line163="        }" line164="        // 50hz: 20,000 us" line165="        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4" line166="        let value = v_us * 4096 / 20000" line167="        setPwm(index + 7, 0, value)" line168="    }" line169="" line170="}" numlines="171"></mutation></block></statement></block></xml>